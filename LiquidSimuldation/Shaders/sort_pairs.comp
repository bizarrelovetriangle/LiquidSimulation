#version 430 core
#include "common.glsl"

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) buffer ParticlesInput
{
    Particle particles[];
};
layout(std430, binding = 1) buffer GridInput
{
    GridCell grid[];
};
layout(std430, binding = 2) buffer PairsCount
{
    int pairs_count;
};
layout(std430, binding = 3) buffer PairsOutput
{
    PairData pairs[];
};
layout(std430, binding = 4) buffer PairsTemp
{
    PairData pairs_temp[];
};

layout(location = 0) uniform ivec2 gridSize;

void RadixSort(bool vertical);
void UpdateGrid();

void main() {
	RadixSort(false);
	RadixSort(true);
	UpdateGrid();
}

void RadixSort(bool vertical) {
	const int chunk_size = 8;
	const int buckets_size = 1 << chunk_size;
	const int mask = buckets_size - 1;

	for (int chunk_index = 0; chunk_index < 32; chunk_index += chunk_size) {
		int buckets[buckets_size];
		int bucket_indexes[buckets_size];

		for (int i = 0; i < buckets_size; ++i) {
			buckets[i] = 0;
			bucket_indexes[i] = 0;
		}

		for (int i = 0; i < pairs_count; ++i) {
			ivec2 pos = particles[pairs[i].first].gridPosition;
			int value = vertical ? pos.y : pos.x;
			int hash = value >> chunk_index & mask;
			buckets[hash]++;
		}

		for (int i = 1; i < buckets_size; ++i) {
			bucket_indexes[i] = bucket_indexes[i - 1] + buckets[i - 1];
		}

		for (int i = 0; i < pairs_count; ++i) {
			ivec2 pos = particles[pairs[i].first].gridPosition;
			int value = vertical ? pos.y : pos.x;
			int hash = value >> chunk_index & mask;
			int index = bucket_indexes[hash]++;
			pairs_temp[index] = pairs[i];
		}

		for (int i = 0; i < pairs_count; ++i) {
			pairs[i] = pairs_temp[i];
		}
	}
}

void UpdateGrid() {
	for (int i = 0; i < gridSize.y * gridSize.x; ++i) {
		grid[i].pairs_start = 0;
		grid[i].pairs_end = 0;
	}
	
	ivec2 last_position = particles[pairs[0].first].gridPosition;
	for (int i = 1; i < pairs_count; ++i) {
		ivec2 grid_position = particles[pairs[i].first].gridPosition;
		if (last_position == grid_position) continue;
	
		grid[last_position.y * gridSize.x + last_position.x].pairs_end = i;
		grid[grid_position.y * gridSize.x + grid_position.x].pairs_start = i;
		last_position = grid_position;
	}
	grid[last_position.y * gridSize.x + last_position.x].pairs_end = pairs_count;
}